## 第一章
###1. 表1.1中若只包含编号为1，4的两个样例，试给出相应的版本空间
`假设空间:`所有可能的组合构成的集合
`版本空间:`利用样本数据分析而获得的组合集合,与训练集一致的假设集合
| 编号  | 色泽  |  根蒂  |  敲声  |  好瓜  |
| ---   | :-----:  | :----:  | :--: |  :-:   |
| 1     | 青绿 |	蜷缩	 | 浊响 |	是  |
| 2     |乌黑  |	稍蜷	|沉闷	|否     |
>假设数据集有$n$种属性，第$i$个属性可能的取值有$t_i$种，加上该属性的泛化取值$(*)$，所以可能的假设有$\prod_{i=1}^n(t_i+1)$。再用空集表示没有正例，所以假设空间中一共$\prod_{i=1}^n(t_i+1)+1$种假设。 
数据集有3个属性，每个属性2种取值，一共3∗3∗3+1=283∗3∗3+1=28种假设，分别为:
>>1. 色泽=青绿 根蒂=蜷缩 敲声=浊响
2. 色泽=青绿 根蒂=蜷缩 敲声=沉闷
3. 色泽=青绿 根蒂=稍蜷 敲声=浊响
4. 色泽=青绿 根蒂=稍蜷 敲声=沉闷
5. 色泽=乌黑 根蒂=蜷缩 敲声=浊响
6. 色泽=乌黑 根蒂=蜷缩 敲声=沉闷
7. 色泽=乌黑 根蒂=稍蜷 敲声=浊响
8. 色泽=乌黑 根蒂=稍蜷 敲声=沉闷
9. 色泽=青绿 根蒂=蜷缩 敲声=*
10. 色泽=青绿 根蒂=稍蜷 敲声=*
11. 色泽=乌黑 根蒂=蜷缩 敲声=*
12. 色泽=乌黑 根蒂=稍蜷 敲声=*
13. 色泽=青绿 根蒂=* 敲声=浊响
14. 色泽=青绿 根蒂=* 敲声=沉闷
15. 色泽=乌黑 根蒂=* 敲声=浊响
16. 色泽=乌黑 根蒂=* 敲声=沉闷
17. 色泽=* 根蒂=蜷缩 敲声=浊响
18. 色泽=* 根蒂=蜷缩 敲声=沉闷
19. 色泽=* 根蒂=稍蜷 敲声=浊响
20. 色泽=* 根蒂=稍蜷 敲声=沉闷
21. 色泽=青绿 根蒂=* 敲声=*
22. 色泽=乌黑 根蒂=* 敲声=*
23. 色泽=* 根蒂=蜷缩 敲声=*
24. 色泽=* 根蒂=稍蜷 敲声=*
25. 色泽=* 根蒂=* 敲声=浊响
26. 色泽=* 根蒂=* 敲声=沉闷
27. 色泽=* 根蒂=* 敲声=*
28. 空集Ø 

>编号1的数据可以删除 2−8，10−12，14−16，18−20，22，24，26，282−8，10−12，14−16，18−20，22，24，26，28(不包含数据1) 
编号1的数据可以删除 2727(包含了数据2) 
所以版本空间为:
>>1.色泽=青绿 根蒂=蜷缩 敲声=浊响
9.色泽=青绿 根蒂=蜷缩 敲声=*
13.色泽=青绿 根蒂=* 敲声=浊响
17.色泽=* 根蒂=蜷缩 敲声=浊响
21.色泽=青绿 根蒂=* 敲声=*
23.色泽=* 根蒂=蜷缩 敲声=*
25.色泽=* 根蒂=* 敲声=浊响

>一般情况下版本空间是正例的泛化，但由于数据集中只有1个正例，所以在版本空间中依然包含了这个样本的假设(假设1)。

<br/>
###2. 与使用单个合取式来进行假设表示相比，使用“析合范式”将使得假设空间具有更强的表示能力。若使用最多包含k个合取式的析合范式来表达1.1的西瓜分类问题的假设空间，试估算有多少种可能的假设
>表1.1包含4个样例，3种属性，假设空间中有3∗4∗4+1=493∗4∗4+1=49种假设。在不考虑冗余的情况下，最多包含k个合取式来表达假设空间，显然k的最大值是49，每次从中选出k个来组成析合式，共$\sum_{k=0}^{49}C^k_{49}$=$2^{49}$种可能。但是其中包含了很多冗余的情况(至少存在一个合取式被剩余的析合式完全包含<空集除外>)

---

>如果考虑冗余的情况 
在这里忽略空集，一是并不是太明白空集是否应该加入析合式，另外就算需要加入，求出了前面48种假设的组合，可以很容易求出加入空集后的组合数(每种可能都可以加上空集，再加上1种空集单独的情况)。 
48种假设中： 
具体假设：2∗3∗3=182∗3∗3=18种 
一个属性泛化假设：2∗3+3∗3+2∗3=212∗3+3∗3+2∗3=21种 
两个属性泛化假设：2+3+3=82+3+3=8种 
三属性泛化：11种 
1. 当k=11时，任选一种假设都可以作为一种没有沉余的假设，共48种。 
2. k的最大值是18，当k等于18时，就是18种具体属性假设的析取式，共1种。 
 
>当k取中间值时，就不好分析了，使用穷竭搜索,这里给出几类假设定义：
`具体假设:`该假设不存在泛化假设,如：色泽=青绿 根蒂=蜷缩 敲声=浊响
`泛化假设:`该假设存在泛化假设,如：色泽=* 根蒂=蜷缩 敲声=*
`假设:`具体假设+泛化假设

为了判断是否冗余，需要判断

- 当前析合式是否包含当前假设
- 当前假设是否包含当前析合式

对于第二种情况，把所有假设按三属性泛化，二属性泛化，一属性泛化，具体属性排序(这样可以保证排在后面的假设不会包含前面的任何一个假设，省略了该种情况的判断)
所以只需考虑第一种判断
>- 使用栈来实现非递归，如果当前假设还有没被析合式所包含的具体假设，则认为可以入栈，并当前栈大小的长度计数加11，并继续扫描。
- 如果当前扫描已经到了最后一个假设，或者所有具体假设已经被全部包含，则退栈。
- 循环结束条件：当最后一个假设作为第一个压入栈的元素时，认为已经遍历结束。

由于一共有18种具体假设，可以用一个32位整型(变量为hypos_cur)的后18位来表示每一个具体假设。用1表示具体假设没被包含，用0表示具体假设已经被析合式包含。初始的析合式为空，可以设初试值为$0X3FFFF$。
每个假设也对应一个32位整型变量(hypo_const),表示它所对应哪些具体假设，如果它包含了某种具体假设，则该位为1。
>- 判断析合式是否包含了全部的具体假设：hypos_cur=0。
- 判断该假设是否已经被析合范式包含:用hypo_const与hypos_cur做$\land$运算(结果用hypo_tmp表示)，如果为0表示已经被包含
- 判断该假设是否包含了当前的析合式:用hypo_const与hypos_cur做$\lor$运算，如果为$0X3FFFFF$，则认为该假设包含了当前析合式，但由于前面对所有假设做了排序，不可能出现这种情况，所以可以省略该判断。
- 当某个假设加入析合范式后(入栈)用hypos_cur与hypo_tmp做异或运算，来更改析合式所包含的具体假设。
- 出栈时再次用hypos_cur与hypo_tmp做异或，回到加入该假设前的情况。

`代码`
``` C++
#include <cstdio>
#include <vector>
#include <stack>

using namespace std;

//在析合式中,用0表示包含相应具体假设，用1表示不包含相应具体假设
//在假设中，用1表示包含相应具体假设，用0表示不包含相应具体假设

static const char list[] =                  //具体类列表
{
    0,0,0, 0,0,1, 0,0,2, 0,0,3, 0,1,0, 0,2,0,
    0,3,0, 1,0,0, 2,0,0, 0,1,1, 0,1,2, 0,1,3,
    0,2,1, 0,2,2, 0,2,3, 0,3,1, 0,3,2, 0,3,3,
    1,0,1, 1,0,2, 1,0,3, 2,0,1, 2,0,2, 2,0,3,
    1,1,0, 1,2,0, 1,3,0, 2,1,0, 2,2,0, 2,3,0,
    1,1,1, 1,1,2, 1,1,3, 1,2,1, 1,2,2, 1,2,3,
    1,3,1, 1,3,2, 1,3,3, 2,1,1, 2,1,2, 2,1,3,
    2,2,1, 2,2,2, 2,2,3, 2,3,1, 2,3,2, 2,3,3
};

class base
{
    virtual int check_redundancy(int) = 0;      //冗余检查接口
};

class hypothesis : public base      //假设类
{
private:
    int hypo_include;   //该假设所包含的所有具体假设，1表示包含，0表示不包含
public:
    hypothesis(int a,int b,int c)
    {
        hypo_include = 0;
        vector<char> p[3];
        if(a == 0)
        {
            p[0].push_back(1);
            p[0].push_back(2);
        }
        else
            p[0].push_back(a);
        if (b == 0)
        {
            p[1].push_back(1);
            p[1].push_back(2);
            p[1].push_back(3);
        }
        else
            p[1].push_back(b);
        if (c == 0)
        {
            p[2].push_back(1);
            p[2].push_back(2);
            p[2].push_back(3);
        }
        else
            p[2].push_back(c);
      for(unsigned int i = 0;i < p[0].size();i++)
            for(unsigned int j = 0;j < p[1].size();j++)
                for(unsigned int k = 0;k < p[2].size();k++)
                    hypo_include |= (1 << (p[0][i] * 9 + p[1][j] * 3 + p[2][k] - 13));
    }

    int check_redundancy(int dnf)       //检查是否与当前析取范式(DNF)冗余，并返回不在析合范式里的具体假设
    {
        return (dnf & hypo_include);
    }
};

class stack_element     //假设在栈中的形式
{
public:
    stack_element(int _hypothesis,int _ptr)
    {
        hypothesis = _hypothesis;
        ptr = _ptr;
    }
    int hypothesis;
    int ptr;
};

class Traversal
{
private:
    vector<int> sum;        //不同k对应的组合数
    stack<stack_element> ss;    //存放析合式中包含的假设
    int DNF;    //
    vector<hypothesis> hypotheses;
public:
    Traversal()
    {
        DNF = 0x3fffff;
        for(int i = 0;i<48;i++)
            hypotheses.push_back(hypothesis(list[3*i], list[3*i+1], list[3*i+2]));
    }

    void search(int start_position)
    {
        int ptr = start_position;
        while(1)
        {
            if(ptr > 47 && !ss.size())
                break;
            if(ptr > 47 || DNF == 0)
            {
                stack_element tmp = ss.top();
                DNF ^= tmp.hypothesis;
                ptr = tmp.ptr + 1;
                ss.pop();
                continue;
            }

            if(int uninclude_concrete_hypothesis = hypotheses[ptr].check_redundancy(DNF))
            {
                DNF ^= uninclude_concrete_hypothesis;
                ss.push(stack_element(uninclude_concrete_hypothesis,ptr));
                if(sum.size() < ss.size())
                    sum.push_back(0);
                sum[ss.size()-1]++;
            }
            ptr++;
        }
        return;
    }

    void print()
    {
         for (unsigned int i = 0;i < sum.size();i++)
            printf("length %d : %d\n", i + 1, sum[i]);
    }
};

int main()
{
    Traversal t;
    t.search(0);
    t.print();
    return 0;
}
```
<br/>
###3.若数据包含噪声，则假设空间中有可能不存在与所有训练样本都一致的假设。在此情形下，请设计一种归纳偏好用于假设选择

>一般来说，当同一个假设对应多个不同的标签时，会出现该类问题。
1. 考虑数据清理，将矛盾的样本删去，但会导致相应信息的丢失。
2. 检查与该样本距离较近的其他样本，采用K-means方法进行处理，即以在其邻域空间内出现次数最多的标签为准。

###4. 本章1.4节在论述“没有免费的午餐”定理时，默认使用了“分类错误率”作为性能度量来对分类器进行评估。若换用其他性能度量$\ell$,试证明没有免费的午餐”定理仍成立
>在1.4节，作者使用了指示函数来作为$\ell$,通过证明我们可以看到，真正的关键在于真实的目标函数$\mathcal{f}$服从均匀分布，即有可能是任意的形态。
对于有X个样本的二分类问题，显然$f$共有$2^X$种情况。其中一半是与假设一致的，也就是$P(f(x)=h(x))=0.5$。 
此时， $$E_{ote}(\mathfrak{L}_a|X,f) = \sum_h\sum_{\mathbf{x}\in\chi-X}P(\mathbf{x})\ell(h(\mathbf{x}),f(\mathbf{x}))P(h|X,\mathfrak{L}_a)$$
所以总性能效用是之和的四分之一，为常数。